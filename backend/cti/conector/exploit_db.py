import csv
import requests
import logging
from stix2 import Vulnerability, Identity, Bundle
from opensearchpy import OpenSearch
import uuid

# Configuración de OpenSearch
OPENSEARCH_HOST = "https://localhost:9201"
OPENSEARCH_USER = "admin"
OPENSEARCH_PASSWORD = "Soporte18*"
INDEX_NAME = "exploit_db"

# Configuración de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Conexión a OpenSearch
client = OpenSearch(
    hosts=[OPENSEARCH_HOST],
    http_auth=(OPENSEARCH_USER, OPENSEARCH_PASSWORD),
    use_ssl=True,
    verify_certs=False
)

# Definir el mapeo del índice
mapping = {
    "mappings": {
        "properties": {
            "id": {"type": "keyword"},
            "file": {"type": "keyword"},
            "description": {"type": "text"},
            "date_published": {"type": "date"},
            "author": {"type": "keyword"},
            "type": {"type": "keyword"},
            "platform": {"type": "keyword"},
            "port": {"type": "integer"}
        }
    }
}

# Crear el índice si no existe
if not client.indices.exists(index=INDEX_NAME):
    client.indices.create(index=INDEX_NAME, body=mapping)
    logger.info(f"Índice '{INDEX_NAME}' creado con el mapeo.")

# Descargar el archivo CSV de Exploit-DB
def download_exploit_db_csv():
    url = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
    response = requests.get(url)
    if response.status_code == 200:
        logger.info("Archivo CSV de Exploit-DB descargado exitosamente.")
        return response.content.decode('utf-8', errors='replace')
    else:
        logger.error(f"Error al descargar el archivo CSV: {response.status_code}")
        return None

# Procesar y indexar los datos de Exploit-DB
def process_and_index_exploit_data(csv_content):
    reader = csv.DictReader(csv_content.splitlines())
    stix_objects = []

    for row in reader:
        # Crear una identidad para el autor
        author_identity = Identity(
            id=f"identity--{uuid.uuid4()}",
            name=row["author"],
            identity_class="individual"
        )
        stix_objects.append(author_identity)

        # Crear un objeto STIX Vulnerability
        vulnerability = Vulnerability(
            id=f"vulnerability--{uuid.uuid4()}",
            created_by_ref=author_identity.id,
            name=row["description"],
            description=row["description"],
            external_references=[{
                "source_name": "Exploit-DB",
                "url": f"https://www.exploit-db.com/exploits/{row['id']}",
                "external_id": row["id"]
            }]
        )
        stix_objects.append(vulnerability)

        # Preparar el documento para OpenSearch
        document = {
            "id": row["id"],
            "file": row["file"],
            "description": row["description"],
            "date_published": row["date_published"],
            "author": row["author"],
            "type": row["type"],
            "platform": row["platform"],
            "port": int(row["port"]) if row["port"] else None
        }

        # Indexar en OpenSearch
        try:
            client.index(index=INDEX_NAME, id=row["id"], body=document)
            logger.info(f"Exploit con ID {row['id']} indexado correctamente.")
        except Exception as e:
            logger.error(f"Error al indexar el exploit con ID {row['id']}: {e}")

    # Crear un Bundle STIX con todos los objetos
    bundle = Bundle(objects=stix_objects)
    return bundle

def main():
    csv_content = download_exploit_db_csv()
    if csv_content:
        stix_bundle = process_and_index_exploit_data(csv_content)
        # Guardar el bundle STIX en un archivo
        with open('exploit_db_stix.json', 'w') as f:
            f.write(str(stix_bundle))
        logger.info("Datos de Exploit-DB procesados y convertidos a STIX 2.0.")

if __name__ == "__main__":
    main()
